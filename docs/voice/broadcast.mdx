---
title: Voice Call Broadcasting
description: Send voice messages to multiple recipients simultaneously using the Sendexa Voice Broadcast API.
date: 2025-03-12
---

# Voice Call Broadcasting

Send voice messages to multiple recipients simultaneously. Perfect for emergency alerts, announcements, political campaigns, and marketing messages.

---

## Quick Start

### Simple Broadcast

```bash
curl -X POST 'https://api.sendexa.co/v1/voice/broadcast' \
  -H 'Authorization: Bearer sk_live_your_token' \
  -H 'Content-Type: application/json' \
  -d '{
    "to": ["233501234567", "233509876543", "233543219876"],
    "from": "233302123456",
    "message": "This is an important announcement from City Hall",
    "voice": "female"
  }'
```

### Broadcast with Audio File

```bash
curl -X POST 'https://api.sendexa.co/v1/voice/broadcast' \
  -H 'Authorization: Bearer sk_live_your_token' \
  -H 'Content-Type: application/json' \
  -d '{
    "to": ["233501234567", "233509876543"],
    "from": "233302123456",
    "audio_url": "https://yourapp.com/announcement.mp3"
  }'
```

---

## Endpoint

### POST /v1/voice/broadcast

Send voice messages to multiple recipients.

**Base URL:** `https://api.sendexa.co`

**Rate Limit:** 30 requests per minute

---

## Request Parameters

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `to` | array | Yes | Array of recipient phone numbers (max 10,000) |
| `from` | string | Yes | Your Sendexa phone number |
| `message` | string | Yes* | Text message to speak (TTS) |
| `audio_url` | string | Yes* | URL to audio file to play |
| `voice` | string | No | TTS voice (male/female, default: female) |
| `language` | string | No | TTS language code (default: en-US) |
| `status_callback` | string | No | Webhook URL for broadcast events |
| `priority` | string | No | Broadcast priority (high/normal, default: normal) |
| `retry_failed` | boolean | No | Retry failed calls (default: true) |
| `max_retries` | integer | No | Maximum retry attempts (default: 2) |
| `schedule_at` | string | No | ISO 8601 timestamp for scheduling |

*Either `message` or `audio_url` is required

---

## Parameter Details

### to (Recipients)

Array of phone numbers in international format:

```json
{
  "to": [
    "233501234567",
    "233509876543",
    "233543219876",
    "254712345678"
  ]
}
```

**Limits:**
- Minimum: 2 recipients
- Maximum: 10,000 recipients per request
- For larger lists, split into batches

### from (Caller ID)

Your Sendexa phone number:

```json
{
  "from": "233302123456"
}
```

### message (TTS Text)

Text to be spoken using text-to-speech:

```json
{
  "message": "This is an emergency alert. Please evacuate the building immediately.",
  "voice": "female",
  "language": "en-US"
}
```

**Character Limit:** 3000 characters

### audio_url (Audio File)

URL to pre-recorded audio file:

```json
{
  "audio_url": "https://yourapp.com/emergency-alert.mp3"
}
```

**Requirements:**
- HTTPS URL
- Formats: MP3, WAV, OGG
- Max size: 10MB
- Max duration: 5 minutes

### priority

Control call urgency:

```json
{
  "priority": "high"
}
```

**Options:**
- `high` - Immediate delivery (use for emergencies)
- `normal` - Standard delivery (default)

### schedule_at

Schedule broadcast for future time:

```json
{
  "schedule_at": "2025-03-15T10:00:00Z"
}
```

**Requirements:**
- ISO 8601 format with timezone
- Must be in the future
- Maximum 30 days ahead

---

## Response Format

### Success Response

```json
{
  "success": true,
  "message": "Broadcast initiated successfully",
  "broadcast": {
    "id": "broadcast_abc123def456",
    "from": "233302123456",
    "recipients_count": 1000,
    "status": "queued",
    "priority": "normal",
    "created_at": "2025-03-12T14:20:00Z",
    "scheduled_at": null
  }
}
```

### Response Fields

| Field | Type | Description |
|-------|------|-------------|
| `success` | boolean | Whether request succeeded |
| `message` | string | Human-readable status |
| `broadcast` | object | Broadcast details |
| `id` | string | Unique broadcast identifier |
| `from` | string | Caller number |
| `recipients_count` | integer | Number of recipients |
| `status` | string | Broadcast status |
| `priority` | string | Priority level |
| `created_at` | string | Creation timestamp |
| `scheduled_at` | string | Scheduled time (if scheduled) |

---

## Code Examples

### JavaScript / Node.js

```javascript
const axios = require('axios');

async function broadcastVoiceMessage(recipients, from, message) {
  try {
    const response = await axios.post(
      'https://api.sendexa.co/v1/voice/broadcast',
      {
        to: recipients,
        from,
        message,
        voice: 'female',
        language: 'en-US',
        status_callback: 'https://yourapp.com/webhooks/broadcast',
        priority: 'normal',
        retry_failed: true
      },
      {
        headers: {
          'Authorization': 'Bearer sk_live_your_token',
          'Content-Type': 'application/json'
        }
      }
    );

    console.log('Broadcast initiated:', response.data.broadcast.id);
    console.log('Recipients:', response.data.broadcast.recipients_count);
    return response.data;
  } catch (error) {
    console.error('Error:', error.response?.data || error.message);
    throw error;
  }
}

// Send broadcast
const recipients = [
  '233501234567',
  '233509876543',
  '233543219876'
];

await broadcastVoiceMessage(
  recipients,
  '233302123456',
  'This is an important announcement. Please listen carefully.'
);

// Broadcast with audio file
async function broadcastWithAudio(recipients, from, audioUrl) {
  const response = await axios.post(
    'https://api.sendexa.co/v1/voice/broadcast',
    {
      to: recipients,
      from,
      audio_url: audioUrl
    },
    {
      headers: {
        'Authorization': 'Bearer sk_live_your_token',
        'Content-Type': 'application/json'
      }
    }
  );
  
  return response.data;
}

await broadcastWithAudio(
  recipients,
  '233302123456',
  'https://yourapp.com/announcement.mp3'
);
```

### Python

```python
import requests
from datetime import datetime, timedelta

def broadcast_voice_message(recipients, from_number, message):
    """Broadcast voice message to multiple recipients"""
    url = 'https://api.sendexa.co/v1/voice/broadcast'
    headers = {
        'Authorization': 'Bearer sk_live_your_token',
        'Content-Type': 'application/json'
    }
    payload = {
        'to': recipients,
        'from': from_number,
        'message': message,
        'voice': 'female',
        'language': 'en-US',
        'status_callback': 'https://yourapp.com/webhooks/broadcast',
        'priority': 'normal',
        'retry_failed': True
    }

    try:
        response = requests.post(url, json=payload, headers=headers)
        response.raise_for_status()
        data = response.json()
        
        print(f"Broadcast initiated: {data['broadcast']['id']}")
        print(f"Recipients: {data['broadcast']['recipients_count']}")
        return data
    except requests.exceptions.RequestException as e:
        print(f"Error: {e}")
        raise

# Send broadcast
recipients = [
    '233501234567',
    '233509876543',
    '233543219876'
]

broadcast_voice_message(
    recipients,
    '233302123456',
    'This is an important announcement. Please listen carefully.'
)

# Broadcast with audio file
def broadcast_with_audio(recipients, from_number, audio_url):
    """Broadcast pre-recorded audio"""
    url = 'https://api.sendexa.co/v1/voice/broadcast'
    headers = {
        'Authorization': 'Bearer sk_live_your_token',
        'Content-Type': 'application/json'
    }
    payload = {
        'to': recipients,
        'from': from_number,
        'audio_url': audio_url
    }
    
    response = requests.post(url, json=payload, headers=headers)
    response.raise_for_status()
    return response.json()

broadcast_with_audio(
    recipients,
    '233302123456',
    'https://yourapp.com/announcement.mp3'
)

# Schedule broadcast
def schedule_broadcast(recipients, from_number, message, schedule_time):
    """Schedule broadcast for future delivery"""
    url = 'https://api.sendexa.co/v1/voice/broadcast'
    headers = {
        'Authorization': 'Bearer sk_live_your_token',
        'Content-Type': 'application/json'
    }
    payload = {
        'to': recipients,
        'from': from_number,
        'message': message,
        'schedule_at': schedule_time.isoformat()
    }
    
    response = requests.post(url, json=payload, headers=headers)
    response.raise_for_status()
    return response.json()

# Schedule for tomorrow at 9 AM
tomorrow_9am = datetime.now() + timedelta(days=1)
tomorrow_9am = tomorrow_9am.replace(hour=9, minute=0, second=0)

schedule_broadcast(
    recipients,
    '233302123456',
    'Scheduled announcement',
    tomorrow_9am
)
```

### PHP

```php
<?php

function broadcastVoiceMessage($recipients, $from, $message) {
    $url = 'https://api.sendexa.co/v1/voice/broadcast';
    $token = 'sk_live_your_token';
    
    $data = [
        'to' => $recipients,
        'from' => $from,
        'message' => $message,
        'voice' => 'female',
        'language' => 'en-US',
        'status_callback' => 'https://yourapp.com/webhooks/broadcast',
        'priority' => 'normal',
        'retry_failed' => true
    ];
    
    $ch = curl_init($url);
    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
    curl_setopt($ch, CURLOPT_POST, true);
    curl_setopt($ch, CURLOPT_POSTFIELDS, json_encode($data));
    curl_setopt($ch, CURLOPT_HTTPHEADER, [
        'Authorization: Bearer ' . $token,
        'Content-Type: application/json'
    ]);
    
    $response = curl_exec($ch);
    $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);
    curl_close($ch);
    
    if ($httpCode === 200) {
        $result = json_decode($response, true);
        echo "Broadcast initiated: " . $result['broadcast']['id'] . "\n";
        echo "Recipients: " . $result['broadcast']['recipients_count'] . "\n";
        return $result;
    } else {
        throw new Exception("Broadcast failed: " . $response);
    }
}

// Send broadcast
$recipients = [
    '233501234567',
    '233509876543',
    '233543219876'
];

broadcastVoiceMessage(
    $recipients,
    '233302123456',
    'This is an important announcement. Please listen carefully.'
);

// Broadcast with audio file
function broadcastWithAudio($recipients, $from, $audioUrl) {
    $url = 'https://api.sendexa.co/v1/voice/broadcast';
    $token = 'sk_live_your_token';
    
    $data = [
        'to' => $recipients,
        'from' => $from,
        'audio_url' => $audioUrl
    ];
    
    $ch = curl_init($url);
    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
    curl_setopt($ch, CURLOPT_POST, true);
    curl_setopt($ch, CURLOPT_POSTFIELDS, json_encode($data));
    curl_setopt($ch, CURLOPT_HTTPHEADER, [
        'Authorization: Bearer ' . $token,
        'Content-Type: application/json'
    ]);
    
    $response = curl_exec($ch);
    curl_close($ch);
    
    return json_decode($response, true);
}

broadcastWithAudio(
    $recipients,
    '233302123456',
    'https://yourapp.com/announcement.mp3'
);
?>
```

---

## Common Use Cases

### 1. Emergency Alerts

```javascript
// Send urgent emergency alert
async function sendEmergencyAlert(residents, message) {
  return await axios.post(url, {
    to: residents,
    from: emergencyLine,
    message: message,
    voice: 'female',
    language: 'en-US',
    priority: 'high',
    retry_failed: true,
    max_retries: 3
  });
}

await sendEmergencyAlert(
  residentsPhoneNumbers,
  'Emergency Alert: Severe weather warning in your area. Seek shelter immediately.'
);
```

### 2. Political Campaigns

```javascript
// Political campaign message
async function sendCampaignMessage(voters, candidate) {
  const message = `Hello, this is a message from ${candidate.name}. 
    Your vote matters in the upcoming election on ${candidate.electionDate}. 
    Together we can make a difference.`;
  
  // Split into batches of 1000
  const batches = chunkArray(voters, 1000);
  
  for (const batch of batches) {
    await broadcastVoiceMessage(
      batch,
      candidate.phoneNumber,
      message
    );
    
    // Wait 1 minute between batches to respect rate limits
    await new Promise(r => setTimeout(r, 60000));
  }
}
```

### 3. School Announcements

```javascript
// School closure announcement
async function announceSchoolClosure(parents, date, reason) {
  const message = `This is an announcement from ABC School. 
    School will be closed on ${date} due to ${reason}. 
    All students should stay at home. Regular classes will resume the next day.`;
  
  return await broadcastVoiceMessage(
    parents,
    schoolPhone,
    message
  );
}

await announceSchoolClosure(
  parentPhoneNumbers,
  'March 15th',
  'severe weather conditions'
);
```

### 4. Event Reminders

```javascript
// Event reminder broadcast
async function sendEventReminder(attendees, event) {
  const message = `Hello, this is a reminder about ${event.name} 
    happening tomorrow at ${event.time} at ${event.venue}. 
    We look forward to seeing you there!`;
  
  // Schedule for day before event
  const reminderTime = new Date(event.date);
  reminderTime.setDate(reminderTime.getDate() - 1);
  reminderTime.setHours(18, 0, 0); // 6 PM
  
  return await axios.post(url, {
    to: attendees,
    from: organizerPhone,
    message: message,
    schedule_at: reminderTime.toISOString()
  });
}
```

### 5. Debt Collection

```javascript
// Payment reminder broadcast
async function sendPaymentReminders(debtors) {
  const message = `This is a friendly reminder about your outstanding payment. 
    Please contact our office to discuss payment options. 
    Thank you.`;
  
  return await broadcastVoiceMessage(
    debtors.map(d => d.phone),
    companyPhone,
    message
  );
}
```

---

## Batch Processing

### Large Recipient Lists

For broadcasts with 10,000+ recipients:

```javascript
function chunkArray(array, size) {
  const chunks = [];
  for (let i = 0; i < array.length; i += size) {
    chunks.push(array.slice(i, i + size));
  }
  return chunks;
}

async function sendLargeBroadcast(recipients, from, message) {
  // Split into batches of 1000
  const batches = chunkArray(recipients, 1000);
  const results = [];
  
  console.log(`Sending to ${recipients.length} recipients in ${batches.length} batches`);
  
  for (let i = 0; i < batches.length; i++) {
    console.log(`Sending batch ${i + 1}/${batches.length}...`);
    
    try {
      const result = await broadcastVoiceMessage(
        batches[i],
        from,
        message
      );
      results.push(result);
      
      // Wait to respect rate limits (30 requests per minute)
      if (i < batches.length - 1) {
        await new Promise(r => setTimeout(r, 2000)); // 2 seconds
      }
    } catch (error) {
      console.error(`Batch ${i + 1} failed:`, error.message);
      // Continue with next batch
    }
  }
  
  return results;
}

// Usage
const allRecipients = await getRecipientsList(); // 50,000 numbers
await sendLargeBroadcast(
  allRecipients,
  '233302123456',
  'Important announcement'
);
```

---

## Monitor Broadcast Status

### Get Broadcast Details

```bash
curl -X GET 'https://api.sendexa.co/v1/voice/broadcasts/broadcast_abc123' \
  -H 'Authorization: Bearer sk_live_your_token'
```

### Response

```json
{
  "success": true,
  "broadcast": {
    "id": "broadcast_abc123",
    "from": "233302123456",
    "recipients_count": 1000,
    "status": "in-progress",
    "priority": "normal",
    "stats": {
      "queued": 200,
      "initiated": 300,
      "in_progress": 150,
      "completed": 320,
      "failed": 30
    },
    "created_at": "2025-03-12T14:20:00Z",
    "started_at": "2025-03-12T14:20:05Z"
  }
}
```

### Track Progress

```javascript
async function monitorBroadcast(broadcastId) {
  let completed = false;
  
  while (!completed) {
    const status = await axios.get(
      `https://api.sendexa.co/v1/voice/broadcasts/${broadcastId}`,
      {
        headers: {
          'Authorization': 'Bearer sk_live_your_token'
        }
      }
    );
    
    const stats = status.data.broadcast.stats;
    const total = status.data.broadcast.recipients_count;
    const done = stats.completed + stats.failed;
    const progress = ((done / total) * 100).toFixed(2);
    
    console.log(`Progress: ${progress}% (${done}/${total})`);
    console.log(`Completed: ${stats.completed}, Failed: ${stats.failed}`);
    
    if (done >= total) {
      completed = true;
      console.log('Broadcast completed!');
    } else {
      // Wait 30 seconds before checking again
      await new Promise(r => setTimeout(r, 30000));
    }
  }
}
```

---

## Best Practices

### 1. Recipient Management

```javascript
// Remove duplicates
function removeDuplicates(recipients) {
  return [...new Set(recipients)];
}

// Validate phone numbers
function validateRecipients(recipients) {
  const valid = [];
  const invalid = [];
  
  for (const number of recipients) {
    if (/^\d{10,15}$/.test(number.replace(/[\s\-+]/g, ''))) {
      valid.push(number);
    } else {
      invalid.push(number);
    }
  }
  
  return { valid, invalid };
}

// Clean recipient list
const recipients = await getRecipients();
const unique = removeDuplicates(recipients);
const { valid, invalid } = validateRecipients(unique);

if (invalid.length > 0) {
  console.log(`${invalid.length} invalid numbers removed`);
}

await broadcastVoiceMessage(valid, from, message);
```

### 2. Timing Considerations

```javascript
// Check if good time to broadcast
function isGoodTimeToCall(timezone = 'Africa/Accra') {
  const hour = moment().tz(timezone).hour();
  const day = moment().tz(timezone).day();
  
  // Not on Sundays (0) or outside 9 AM - 8 PM
  return day !== 0 && hour >= 9 && hour < 20;
}

async function scheduleBroadcast(recipients, message) {
  if (isGoodTimeToCall()) {
    // Send immediately
    return await broadcastVoiceMessage(recipients, from, message);
  } else {
    // Schedule for next business day at 9 AM
    const nextTime = moment()
      .tz('Africa/Accra')
      .add(1, 'day')
      .hour(9)
      .minute(0);
    
    // Skip to Monday if weekend
    while (nextTime.day() === 0 || nextTime.day() === 6) {
      nextTime.add(1, 'day');
    }
    
    return await axios.post(url, {
      to: recipients,
      from: from,
      message: message,
      schedule_at: nextTime.toISOString()
    });
  }
}
```

### 3. Cost Management

```javascript
// Estimate broadcast cost
function estimateCost(recipientCount, durationMinutes, pricePerMinute = 0.15) {
  return recipientCount * durationMinutes * pricePerMinute;
}

// Check if within budget
async function broadcastWithBudgetCheck(recipients, message, maxBudget) {
  const estimatedDuration = 1; // Estimate 1 minute per call
  const cost = estimateCost(recipients.length, estimatedDuration);
  
  if (cost > maxBudget) {
    throw new Error(`Estimated cost ($${cost}) exceeds budget ($${maxBudget})`);
  }
  
  console.log(`Estimated cost: $${cost.toFixed(2)}`);
  return await broadcastVoiceMessage(recipients, from, message);
}
```

### 4. Message Quality

```javascript
// Keep message concise and clear
const goodMessage = `
  Emergency Alert: Severe storm approaching. 
  Seek shelter immediately. 
  Stay indoors until further notice.
`;

// Avoid long, complex messages
const badMessage = `
  This is an emergency announcement regarding 
  the severe weather conditions that are currently 
  approaching our area and we need everyone to 
  please take immediate action and seek appropriate 
  shelter in a safe location...
`;
```

### 5. Compliance

```javascript
// Maintain Do Not Call list
async function broadcastWithDNCCheck(recipients, message) {
  // Get Do Not Call list
  const dncList = await getDNCList();
  
  // Filter out DNC numbers
  const allowedRecipients = recipients.filter(
    number => !dncList.includes(number)
  );
  
  console.log(`Removed ${recipients.length - allowedRecipients.length} DNC numbers`);
  
  return await broadcastVoiceMessage(allowedRecipients, from, message);
}
```

---

## Error Handling

### Handle Failed Broadcasts

```javascript
async function broadcastWithRetry(recipients, message, maxAttempts = 3) {
  let attempt = 0;
  let lastError;
  
  while (attempt < maxAttempts) {
    try {
      return await broadcastVoiceMessage(recipients, from, message);
    } catch (error) {
      attempt++;
      lastError = error;
      
      console.log(`Attempt ${attempt} failed:`, error.message);
      
      if (attempt < maxAttempts) {
        // Wait before retry (exponential backoff)
        const delay = Math.pow(2, attempt) * 1000;
        await new Promise(r => setTimeout(r, delay));
      }
    }
  }
  
  throw new Error(`Broadcast failed after ${maxAttempts} attempts: ${lastError.message}`);
}
```

---

## Testing

### Test Broadcast

```javascript
// Test with small group first
const testRecipients = [
  '233500000001', // Test number
  yourPhoneNumber
];

await broadcastVoiceMessage(
  testRecipients,
  '233302123456',
  'This is a test broadcast message'
);

// If successful, proceed with full broadcast
await broadcastVoiceMessage(
  allRecipients,
  '233302123456',
  actualMessage
);
```

---

## Next Steps

- üó£Ô∏è **[Text-to-Speech](/docs/voice/tts)** - Generate speech
- üìû **[Make Calls](/docs/voice/make-call)** - Individual calls
- üéõÔ∏è **[Build IVR](/docs/voice/ivr)** - Interactive menus
- üîî **[Webhooks](/docs/voice/webhooks)** - Real-time events
- üõ†Ô∏è **[API Reference](/docs/voice/v1)** - Complete docs