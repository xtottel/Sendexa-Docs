---
title: WhatsApp Webhooks
description: Receive real-time WhatsApp notifications for messages, delivery status, and user interactions via webhooks.
date: 2025-03-12
---

# WhatsApp Webhooks

Receive real-time notifications for WhatsApp events including message delivery, incoming messages, read receipts, and user interactions.

---

## Overview

### What are Webhooks?

Webhooks are HTTP POST requests sent to your server when WhatsApp events occur. Instead of polling for updates, your application receives instant notifications.

### Key Features

- **Real-time** - Instant event notifications
- **Two-way Messaging** - Receive incoming messages
- **Delivery Tracking** - Monitor message status
- **Interactive Responses** - Handle button clicks and replies
- **Reliable** - Automatic retry mechanism

---

## Webhook Events

### Message Events

#### message.sent

Triggered when message is sent to WhatsApp.

```json
{
  "event": "message.sent",
  "messageId": "wamid.HBgNMjMzNTAxMjM0NTY3FQIAERgSQzFGRjREQTU5OTIzRTdBNzYA",
  "to": "233501234567",
  "type": "text",
  "status": "sent",
  "timestamp": "2025-03-12T14:20:02Z"
}
```

#### message.delivered

Triggered when message is delivered to recipient.

```json
{
  "event": "message.delivered",
  "messageId": "wamid.HBgNMjMzNTAxMjM0NTY3FQIAERgSQzFGRjREQTU5OTIzRTdBNzYA",
  "to": "233501234567",
  "status": "delivered",
  "conversation": {
    "id": "conv_abc123",
    "type": "business_initiated",
    "category": "utility"
  },
  "cost": 0.35,
  "currency": "GHS",
  "deliveredAt": "2025-03-12T14:20:05Z",
  "timestamp": "2025-03-12T14:20:05Z"
}
```

#### message.read

Triggered when recipient reads the message.

```json
{
  "event": "message.read",
  "messageId": "wamid.HBgNMjMzNTAxMjM0NTY3FQIAERgSQzFGRjREQTU5OTIzRTdBNzYA",
  "to": "233501234567",
  "status": "read",
  "readAt": "2025-03-12T14:25:00Z",
  "timestamp": "2025-03-12T14:25:00Z"
}
```

#### message.failed

Triggered when message delivery fails.

```json
{
  "event": "message.failed",
  "messageId": "wamid.HBgNMjMzNTAxMjM0NTY3FQIAERgSQzFGRjREQTU5OTIzRTdBNzYA",
  "to": "233501234567",
  "status": "failed",
  "error": {
    "code": "INVALID_NUMBER",
    "message": "Invalid WhatsApp number",
    "provider_code": "131051"
  },
  "timestamp": "2025-03-12T14:20:03Z"
}
```

### Incoming Message Events

#### message.received

Triggered when you receive a message from a user.

```json
{
  "event": "message.received",
  "messageId": "wamid.HBgNMjMzNTAxMjM0NTY3FQIAERgSQzFGRjREQTU5OTIzRTdBNzYA",
  "from": "233501234567",
  "type": "text",
  "text": {
    "body": "I need help with my order"
  },
  "contact": {
    "name": "John Doe",
    "phone": "233501234567"
  },
  "conversation": {
    "id": "conv_abc123",
    "type": "user_initiated"
  },
  "timestamp": "2025-03-12T14:20:00Z"
}
```

#### message.received (Media)

```json
{
  "event": "message.received",
  "messageId": "wamid.HBgNMjMzNTAxMjM0NTY3FQIAERgSQzFGRjREQTU5OTIzRTdBNzYA",
  "from": "233501234567",
  "type": "image",
  "image": {
    "id": "med_abc123",
    "url": "https://cdn.sendexa.co/media/abc123.jpg",
    "mime_type": "image/jpeg",
    "caption": "Here's the issue"
  },
  "timestamp": "2025-03-12T14:20:00Z"
}
```

### Interactive Events

#### interactive.button_reply

User clicks a button.

```json
{
  "event": "interactive.button_reply",
  "messageId": "wamid.HBgNMjMzNTAxMjM0NTY3FQIAERgSQzFGRjREQTU5OTIzRTdBNzYA",
  "from": "233501234567",
  "type": "interactive",
  "interactive": {
    "type": "button_reply",
    "button_reply": {
      "id": "confirm_yes",
      "title": "Yes, Confirm"
    }
  },
  "context": {
    "messageId": "wamid.parent_message_id"
  },
  "timestamp": "2025-03-12T14:22:00Z"
}
```

#### interactive.list_reply

User selects from a list.

```json
{
  "event": "interactive.list_reply",
  "messageId": "wamid.HBgNMjMzNTAxMjM0NTY3FQIAERgSQzFGRjREQTU5OTIzRTdBNzYA",
  "from": "233501234567",
  "type": "interactive",
  "interactive": {
    "type": "list_reply",
    "list_reply": {
      "id": "sales_quote",
      "title": "Request Quote",
      "description": "Get a price estimate"
    }
  },
  "timestamp": "2025-03-12T14:22:00Z"
}
```

---

## Configuration

### Set Up Webhook

1. **Log in** to [dashboard.sendexa.co](https://dashboard.sendexa.co)
2. Navigate to **WhatsApp ‚Üí Settings ‚Üí Webhooks**
3. Click **Add Webhook**
4. Configure:
   - **URL:** Your HTTPS endpoint
   - **Events:** Select events to receive
   - **Secret:** Generate webhook secret
5. Click **Save & Test**

### Webhook URL Requirements

‚úÖ **Required:**

- Must use HTTPS (not HTTP)
- Must be publicly accessible
- Should respond within 5 seconds
- Should return 200 OK on success

‚ùå **Not Allowed:**

- HTTP URLs
- Localhost/private IPs
- URLs requiring authentication

---

## Implementation

### Node.js / Express

```javascript
const express = require('express');
const crypto = require('crypto');

const app = express();
app.use(express.json());

const WEBHOOK_SECRET = 'your_webhook_secret_from_dashboard';

// Verify webhook signature
function verifySignature(payload, signature) {
  const expectedSignature = crypto
    .createHmac('sha256', WEBHOOK_SECRET)
    .update(JSON.stringify(payload))
    .digest('hex');

  return crypto.timingSafeEqual(
    Buffer.from(signature),
    Buffer.from(expectedSignature)
  );
}

// Webhook endpoint
app.post('/webhooks/sendexa/whatsapp', async (req, res) => {
  const signature = req.headers['x-sendexa-signature'];

  // Verify signature
  if (!verifySignature(req.body, signature)) {
    console.error('Invalid signature');
    return res.status(401).send('Unauthorized');
  }

  const event = req.body;
  console.log('Received event:', event.event);

  // Handle different event types
  switch (event.event) {
    case 'message.sent':
      await handleMessageSent(event);
      break;

    case 'message.delivered':
      await handleMessageDelivered(event);
      break;

    case 'message.read':
      await handleMessageRead(event);
      break;

    case 'message.failed':
      await handleMessageFailed(event);
      break;

    case 'message.received':
      await handleIncomingMessage(event);
      break;

    case 'interactive.button_reply':
      await handleButtonReply(event);
      break;

    case 'interactive.list_reply':
      await handleListReply(event);
      break;

    default:
      console.log('Unknown event:', event.event);
  }

  // Respond quickly
  res.status(200).send('OK');
});

// Event handlers
async function handleMessageSent(event) {
  console.log(`Message sent: ${event.messageId}`);

  await db.messages.update({
    where: { id: event.messageId },
    data: { status: 'sent', sentAt: event.timestamp },
  });
}

async function handleMessageDelivered(event) {
  console.log(`Message delivered: ${event.messageId}`);

  await db.messages.update({
    where: { id: event.messageId },
    data: {
      status: 'delivered',
      deliveredAt: event.deliveredAt,
      cost: event.cost,
    },
  });

  // Notify user
  await notifyUser(event.messageId, 'delivered');
}

async function handleMessageRead(event) {
  console.log(`Message read: ${event.messageId}`);

  await db.messages.update({
    where: { id: event.messageId },
    data: { status: 'read', readAt: event.readAt },
  });
}

async function handleMessageFailed(event) {
  console.error(`Message failed: ${event.messageId}`, event.error);

  await db.messages.update({
    where: { id: event.messageId },
    data: {
      status: 'failed',
      errorCode: event.error.code,
      errorMessage: event.error.message,
    },
  });

  // Alert admin
  await alertAdmin(`Message ${event.messageId} failed: ${event.error.message}`);
}

async function handleIncomingMessage(event) {
  console.log(`Incoming message from: ${event.from}`);

  // Save message
  await db.incomingMessages.create({
    data: {
      messageId: event.messageId,
      from: event.from,
      type: event.type,
      content: event.text?.body || event.image?.url || '',
      timestamp: event.timestamp,
    },
  });

  // Auto-reply logic
  if (event.text?.body) {
    const message = event.text.body.toLowerCase();

    if (message.includes('help')) {
      await sendWhatsApp(event.from, {
        type: 'text',
        text: { body: 'How can we help you today?' },
      });
    } else if (message.includes('order')) {
      await sendWhatsApp(event.from, {
        type: 'interactive',
        interactive: {
          type: 'button',
          body: { text: 'Would you like to check your order status?' },
          action: {
            buttons: [
              {
                type: 'reply',
                reply: { id: 'check_order', title: 'Check Status' },
              },
              { type: 'reply', reply: { id: 'new_order', title: 'New Order' } },
            ],
          },
        },
      });
    }
  }
}

async function handleButtonReply(event) {
  const buttonId = event.interactive.button_reply.id;
  console.log(`Button clicked: ${buttonId}`);

  // Handle button actions
  switch (buttonId) {
    case 'confirm_yes':
      await processConfirmation(event.from);
      break;
    case 'confirm_no':
      await processCancellation(event.from);
      break;
    case 'check_order':
      await sendOrderStatus(event.from);
      break;
    default:
      console.log('Unknown button:', buttonId);
  }
}

async function handleListReply(event) {
  const listId = event.interactive.list_reply.id;
  console.log(`List item selected: ${listId}`);

  // Handle list selection
  switch (listId) {
    case 'sales_quote':
      await sendQuoteForm(event.from);
      break;
    case 'support_tech':
      await routeToTechnicalSupport(event.from);
      break;
    default:
      console.log('Unknown list item:', listId);
  }
}

app.listen(3000, () => {
  console.log('Webhook server listening on port 3000');
});
```

### Python / Flask

```python
from flask import Flask, request, jsonify
import hmac
import hashlib
import json

app = Flask(__name__)

WEBHOOK_SECRET = 'your_webhook_secret_from_dashboard'

def verify_signature(payload, signature):
    """Verify webhook signature"""
    expected_signature = hmac.new(
        WEBHOOK_SECRET.encode(),
        json.dumps(payload).encode(),
        hashlib.sha256
    ).hexdigest()

    return hmac.compare_digest(signature, expected_signature)

@app.route('/webhooks/sendexa/whatsapp', methods=['POST'])
def handle_webhook():
    signature = request.headers.get('X-Sendexa-Signature')
    payload = request.get_json()

    # Verify signature
    if not verify_signature(payload, signature):
        return jsonify({'error': 'Invalid signature'}), 401

    event_type = payload.get('event')
    print(f"Received event: {event_type}")

    # Handle different event types
    if event_type == 'message.sent':
        handle_message_sent(payload)
    elif event_type == 'message.delivered':
        handle_message_delivered(payload)
    elif event_type == 'message.read':
        handle_message_read(payload)
    elif event_type == 'message.failed':
        handle_message_failed(payload)
    elif event_type == 'message.received':
        handle_incoming_message(payload)
    elif event_type == 'interactive.button_reply':
        handle_button_reply(payload)
    elif event_type == 'interactive.list_reply':
        handle_list_reply(payload)
    else:
        print(f"Unknown event: {event_type}")

    return jsonify({'status': 'success'}), 200

def handle_message_sent(event):
    print(f"Message sent: {event['messageId']}")
    # Update database

def handle_message_delivered(event):
    print(f"Message delivered: {event['messageId']}")
    # Update database, notify user

def handle_message_read(event):
    print(f"Message read: {event['messageId']}")
    # Update database

def handle_message_failed(event):
    print(f"Message failed: {event['messageId']}", event['error'])
    # Update database, alert admin

def handle_incoming_message(event):
    print(f"Incoming message from: {event['from']}")

    # Save message to database
    # Implement auto-reply logic

    if event['type'] == 'text':
        message = event['text']['body'].lower()

        if 'help' in message:
            # Send help message
            send_reply(event['from'], 'How can we help you?')
        elif 'order' in message:
            # Send order options
            send_order_options(event['from'])

def handle_button_reply(event):
    button_id = event['interactive']['button_reply']['id']
    print(f"Button clicked: {button_id}")

    # Handle button actions
    if button_id == 'confirm_yes':
        process_confirmation(event['from'])
    elif button_id == 'confirm_no':
        process_cancellation(event['from'])

def handle_list_reply(event):
    list_id = event['interactive']['list_reply']['id']
    print(f"List item selected: {list_id}")

    # Handle list selection
    if list_id == 'sales_quote':
        send_quote_form(event['from'])

if __name__ == '__main__':
    app.run(port=3000)
```

### PHP

```php
<?php

$webhookSecret = 'your_webhook_secret_from_dashboard';

// Get payload and signature
$payload = file_get_contents('php://input');
$signature = $_SERVER['HTTP_X_SENDEXA_SIGNATURE'] ?? '';

// Verify signature
$expectedSignature = hash_hmac('sha256', $payload, $webhookSecret);

if (!hash_equals($signature, $expectedSignature)) {
    http_response_code(401);
    die('Unauthorized');
}

// Parse event
$event = json_decode($payload, true);

// Handle event
switch ($event['event']) {
    case 'message.sent':
        handleMessageSent($event);
        break;

    case 'message.delivered':
        handleMessageDelivered($event);
        break;

    case 'message.read':
        handleMessageRead($event);
        break;

    case 'message.failed':
        handleMessageFailed($event);
        break;

    case 'message.received':
        handleIncomingMessage($event);
        break;

    case 'interactive.button_reply':
        handleButtonReply($event);
        break;

    case 'interactive.list_reply':
        handleListReply($event);
        break;

    default:
        error_log("Unknown event: " . $event['event']);
}

// Respond
http_response_code(200);
echo 'OK';

function handleMessageSent($event) {
    error_log("Message sent: " . $event['messageId']);
    // Update database
}

function handleMessageDelivered($event) {
    error_log("Message delivered: " . $event['messageId']);
    // Update database, notify user
}

function handleMessageRead($event) {
    error_log("Message read: " . $event['messageId']);
    // Update database
}

function handleMessageFailed($event) {
    error_log("Message failed: " . $event['messageId']);
    // Update database, alert admin
}

function handleIncomingMessage($event) {
    error_log("Incoming message from: " . $event['from']);

    // Save to database
    // Implement auto-reply

    if ($event['type'] === 'text') {
        $message = strtolower($event['text']['body']);

        if (strpos($message, 'help') !== false) {
            sendReply($event['from'], 'How can we help you?');
        } elseif (strpos($message, 'order') !== false) {
            sendOrderOptions($event['from']);
        }
    }
}

function handleButtonReply($event) {
    $buttonId = $event['interactive']['button_reply']['id'];
    error_log("Button clicked: " . $buttonId);

    if ($buttonId === 'confirm_yes') {
        processConfirmation($event['from']);
    }
}

function handleListReply($event) {
    $listId = $event['interactive']['list_reply']['id'];
    error_log("List item selected: " . $listId);

    if ($listId === 'sales_quote') {
        sendQuoteForm($event['from']);
    }
}

?>
```

---

## Security

### Signature Verification

Always verify the `X-Sendexa-Signature` header:

```javascript
const crypto = require('crypto');

function verifySignature(payload, signature) {
  const expectedSignature = crypto
    .createHmac('sha256', WEBHOOK_SECRET)
    .update(JSON.stringify(payload))
    .digest('hex');

  return crypto.timingSafeEqual(
    Buffer.from(signature),
    Buffer.from(expectedSignature)
  );
}
```

### Best Practices

1. **Always use HTTPS**
2. **Verify signatures**
3. **Use timing-safe comparison**
4. **Validate payload structure**
5. **Process asynchronously**
6. **Log all webhooks**
7. **Implement idempotency**

---

## Retry Policy

If your endpoint doesn't respond with `200 OK`, Sendexa will retry:

| Attempt | Delay      | Total Elapsed |
| ------- | ---------- | ------------- |
| 1       | Immediate  | 0s            |
| 2       | 30 seconds | 30s           |
| 3       | 2 minutes  | 2.5 min       |
| 4       | 10 minutes | 12.5 min      |
| 5       | 1 hour     | 1h 12.5min    |

### Idempotency

```javascript
const processedEvents = new Set();

app.post('/webhooks/sendexa/whatsapp', (req, res) => {
  const deliveryId = req.headers['x-sendexa-delivery-id'];

  // Check if already processed
  if (processedEvents.has(deliveryId)) {
    return res.status(200).send('OK');
  }

  // Process event
  handleEvent(req.body);

  // Mark as processed
  processedEvents.add(deliveryId);

  res.status(200).send('OK');
});
```

---

## Testing

### Local Development with ngrok

```bash
# Install ngrok
npm install -g ngrok

# Start local server
node server.js

# Create tunnel
ngrok http 3000

# Use HTTPS URL in dashboard
# https://abc123.ngrok.io/webhooks/sendexa/whatsapp
```

### Test Event

Send test events from dashboard:

1. Go to **WhatsApp ‚Üí Settings ‚Üí Webhooks**
2. Select webhook
3. Click **Send Test Event**
4. Choose event type
5. View response

---

## Best Practices

### 1. Async Processing

```javascript
const Queue = require('bull');
const webhookQueue = new Queue('webhooks');

app.post('/webhooks/sendexa/whatsapp', async (req, res) => {
  // Verify signature
  if (!verifySignature(req.body, req.headers['x-sendexa-signature'])) {
    return res.status(401).send('Unauthorized');
  }

  // Queue for processing
  await webhookQueue.add(req.body);

  // Respond immediately
  res.status(200).send('OK');
});

// Process queue
webhookQueue.process(async (job) => {
  const event = job.data;
  await processWebhookEvent(event);
});
```

### 2. Conversation Context

```javascript
async function handleIncomingMessage(event) {
  // Get conversation context
  const context = await db.conversations.findOne({
    phone: event.from,
  });

  if (context && context.state === 'awaiting_order_id') {
    // User is providing order ID
    await handleOrderIdResponse(event.from, event.text.body);
  } else {
    // New conversation
    await handleNewMessage(event);
  }
}
```

### 3. Auto-Reply with Context

```javascript
const conversationStates = new Map();

async function handleIncomingMessage(event) {
  const phone = event.from;
  const state = conversationStates.get(phone) || 'idle';

  if (state === 'awaiting_name') {
    conversationStates.set(phone, 'awaiting_email');
    await sendWhatsApp(phone, {
      type: 'text',
      text: { body: `Thanks ${event.text.body}! What's your email?` }
    });
  } else if (state === 'awaiting_email') {
    conversationStates.delete(phone);
    await completeRegistration(phone, event.text.body);
  } else {
    // Start conversation
    conversationStates.set(phone, 'awaiting_name');
    await sendWhatsApp(phone, {
      type: 'text',
      text: { body: 'Hello! What's your name?' }
    });
  }
}
```

---

## Common Errors

### Error: Signature Mismatch

**Cause:** Wrong webhook secret or modified payload

**Solution:**

- Verify secret from dashboard
- Check raw request body
- Use UTF-8 encoding

### Error: Timeout

**Cause:** Processing takes too long

**Solution:**

- Return 200 OK immediately
- Process asynchronously
- Optimize slow operations

### Error: Duplicate Events

**Cause:** Retries due to slow response

**Solution:**

- Implement idempotency using delivery IDs
- Store processed event IDs

---

## Next Steps

- üì± **[Send Messages](/docs/whatsapp/send)** - Reply to incoming messages
- üì¢ **[Create Broadcasts](/docs/whatsapp/broadcasts)** - Send to multiple contacts
- üë• **[Manage Contacts](/docs/whatsapp/contacts)** - Organize users
- üõ†Ô∏è **[API Reference](/docs/whatsapp/v1)** - Complete documentation
