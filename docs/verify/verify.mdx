---
title: Verify OTP
description: Validate OTP codes with enhanced security including attempt tracking, automatic blocking, and metadata retrieval.
date: 2025-03-12
---

# Verify OTP

Validate user-submitted OTP codes with fintech-grade security features. Includes attempt tracking, automatic blocking after maximum attempts, expiry validation, and single-use enforcement.

---

## Endpoint

### POST /v1/otp/verify

Verify an OTP code against a phone number or email address.

**Base URL:** `https://api.sendexa.co`

**Rate Limit:**

- 10 verification attempts per OTP (configurable)
- 100 verifications per hour per phone/email

---

## Authentication

```http
Authorization: Basic base64(api_key:api_secret)
Content-Type: application/json
```

---

## Request Body

| Parameter | Type   | Required    | Description                   |
| --------- | ------ | ----------- | ----------------------------- |
| `phone`   | string | Conditional | Phone number (for SMS OTP)    |
| `email`   | string | Conditional | Email address (for Email OTP) |
| `code`    | string | Yes         | The OTP code to verify        |
| `id`      | string | No          | Specific OTP record ID        |

**Note:** You must provide either `phone` or `email` (whichever channel was used).

---

## Security Features

### 1. Attempt Tracking

- Tracks every verification attempt
- Configurable maximum attempts (default: 3)
- Automatic blocking after max attempts

### 2. Expiry Validation

- Checks if OTP has expired
- Returns exact expiry timestamp
- Prevents use of expired codes

### 3. Single-Use Enforcement

- OTP automatically invalidated after successful verification
- Cannot be reused even within expiry time
- Prevents replay attacks

### 4. Metadata Retrieval

- Returns original metadata from request
- Useful for transaction validation
- Maintains context throughout flow

---

## Request Examples

### Verify SMS OTP

```bash
curl -X POST 'https://api.sendexa.co/v1/otp/verify' \
  -H 'Authorization: Basic YOUR_BASE64_CREDENTIALS' \
  -H 'Content-Type: application/json' \
  -d '{
    "phone": "0555539152",
    "code": "1234"
  }'
```

### Verify Email OTP

```bash
curl -X POST 'https://api.sendexa.co/v1/otp/verify' \
  -H 'Authorization: Basic YOUR_BASE64_CREDENTIALS' \
  -H 'Content-Type: application/json' \
  -d '{
    "email": "user@example.com",
    "code": "123456"
  }'
```

### Verify Specific OTP Record

```bash
curl -X POST 'https://api.sendexa.co/v1/otp/verify' \
  -H 'Authorization: Basic YOUR_BASE64_CREDENTIALS' \
  -H 'Content-Type: application/json' \
  -d '{
    "phone": "0555539152",
    "code": "1234",
    "id": "clxyz123abc"
  }'
```

---

## Response

### Success Response

```json
{
  "success": true,
  "message": "OTP verified successfully",
  "data": {
    "verified": true,
    "phone": "233555539152",
    "email": null,
    "verifiedAt": "2024-01-15T10:30:45.000Z",
    "pinLength": 4,
    "pinType": "NUMERIC",
    "id": "clxyz123abc",
    "metadata": {
      "userId": "12345",
      "transactionId": "txn_789",
      "transactionType": "withdrawal",
      "amount": 500,
      "currency": "GHS"
    }
  }
}
```

### Response Fields

| Field             | Type    | Description                    |
| ----------------- | ------- | ------------------------------ |
| `success`         | boolean | Whether verification succeeded |
| `message`         | string  | Human-readable status message  |
| `data.verified`   | boolean | Verification status            |
| `data.phone`      | string  | Phone number (if SMS)          |
| `data.email`      | string  | Email address (if Email)       |
| `data.verifiedAt` | string  | ISO timestamp of verification  |
| `data.pinLength`  | integer | Original PIN length            |
| `data.pinType`    | string  | Original PIN type              |
| `data.id`         | string  | OTP record identifier          |
| `data.metadata`   | object  | Original metadata from request |

---

## Error Responses

### 400 Bad Request - Invalid OTP

```json
{
  "success": false,
  "message": "Invalid OTP code",
  "errorType": "INVALID_OTP",
  "data": {
    "attemptsRemaining": 2,
    "maxAttempts": 3
  }
}
```

**Cause:** Wrong OTP code provided

**Solution:** User should re-enter the correct code

### 400 Bad Request - Expired OTP

```json
{
  "success": false,
  "message": "OTP code has expired",
  "errorType": "EXPIRED_OTP",
  "data": {
    "expiredAt": "2024-01-15T10:25:00.000Z",
    "expiryDuration": "5 minutes"
  }
}
```

**Cause:** OTP exceeded its TTL

**Solution:** User should request a new OTP

### 400 Bad Request - Max Attempts Exceeded

```json
{
  "success": false,
  "message": "Maximum validation attempts exceeded",
  "errorType": "MAX_ATTEMPTS_EXCEEDED",
  "data": {
    "maxAttempts": 3,
    "attemptsMade": 3,
    "blockedUntil": "2024-01-15T10:40:00.000Z"
  }
}
```

**Cause:** Exceeded maximum verification attempts

**Solution:** User must request a new OTP

### 404 Not Found - No OTP Found

```json
{
  "success": false,
  "message": "No OTP found for this destination",
  "errorType": "OTP_NOT_FOUND"
}
```

**Cause:** No OTP was sent to this phone/email

**Solution:** Request an OTP first

### 400 Bad Request - Already Used

```json
{
  "success": false,
  "message": "OTP has already been used",
  "errorType": "OTP_ALREADY_USED",
  "data": {
    "usedAt": "2024-01-15T10:28:00.000Z"
  }
}
```

**Cause:** OTP was already successfully verified

**Solution:** Request a new OTP if needed

---

## Code Examples

### JavaScript / Node.js

```javascript
class OTPVerificationService {
  constructor(apiKey, apiSecret) {
    this.baseUrl = 'https://api.sendexa.co/v1/otp';
    this.credentials = btoa(`${apiKey}:${apiSecret}`);
    this.attemptTracking = new Map();
  }

  async verifyOTP(destination, code, channel = 'sms', otpId = null) {
    // Track local attempts
    const attempts = this.attemptTracking.get(destination) || 0;

    if (attempts >= 3) {
      throw new Error(
        'Maximum local attempts exceeded. Please request a new OTP.'
      );
    }

    try {
      const payload = { code };

      if (channel === 'sms') {
        payload.phone = destination;
      } else if (channel === 'email') {
        payload.email = destination;
      }

      if (otpId) payload.id = otpId;

      const response = await fetch(`${this.baseUrl}/verify`, {
        method: 'POST',
        headers: {
          Authorization: `Basic ${this.credentials}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(payload),
      });

      const data = await response.json();

      if (!response.ok) {
        // Increment attempt counter
        this.attemptTracking.set(destination, attempts + 1);

        // Handle specific errors
        if (data.errorType === 'INVALID_OTP') {
          const remaining = data.data?.attemptsRemaining || 0;
          throw new Error(`Invalid OTP. ${remaining} attempts remaining.`);
        } else if (data.errorType === 'EXPIRED_OTP') {
          throw new Error('OTP has expired. Please request a new one.');
        } else if (data.errorType === 'MAX_ATTEMPTS_EXCEEDED') {
          this.attemptTracking.set(destination, 999); // Lock out
          throw new Error('Maximum attempts exceeded. Request a new OTP.');
        } else if (data.errorType === 'OTP_ALREADY_USED') {
          throw new Error('This OTP has already been used.');
        } else if (data.errorType === 'OTP_NOT_FOUND') {
          throw new Error('No OTP found. Please request one first.');
        }

        throw new Error(data.message || 'Verification failed');
      }

      // Clear attempts on success
      this.attemptTracking.delete(destination);

      return data;
    } catch (error) {
      console.error('Verification error:', error);
      throw error;
    }
  }

  getRemainingAttempts(destination) {
    const attempts = this.attemptTracking.get(destination) || 0;
    return Math.max(0, 3 - attempts);
  }

  resetAttempts(destination) {
    this.attemptTracking.delete(destination);
  }
}

// Usage Examples

const verifier = new OTPVerificationService('your_api_key', 'your_api_secret');

// Verify SMS OTP with error handling
async function handleSMSVerification(phone, code) {
  try {
    const result = await verifier.verifyOTP(phone, code, 'sms');

    if (result.success) {
      console.log('‚úÖ Verification successful!');
      console.log('Metadata:', result.data.metadata);

      // Process based on metadata
      const { transactionId, amount } = result.data.metadata;
      await processTransaction(transactionId, amount);

      return true;
    }
  } catch (error) {
    console.error('‚ùå Verification failed:', error.message);

    const remaining = verifier.getRemainingAttempts(phone);
    if (remaining > 0) {
      alert(`${error.message} ${remaining} attempts left.`);
    } else {
      alert('No attempts remaining. Please request a new OTP.');
    }

    return false;
  }
}

// Verify Email OTP
async function handleEmailVerification(email, code) {
  try {
    const result = await verifier.verifyOTP(email, code, 'email');

    if (result.success) {
      console.log('‚úÖ Email verified!');

      // Mark email as verified in database
      await markEmailAsVerified(email);

      return true;
    }
  } catch (error) {
    console.error('‚ùå Verification failed:', error.message);
    return false;
  }
}

// Complete login flow with OTP
async function loginWithOTP(phone, password, otpCode) {
  try {
    // Step 1: Verify credentials
    const user = await verifyCredentials(phone, password);

    if (!user) {
      throw new Error('Invalid credentials');
    }

    // Step 2: Verify OTP
    const otpResult = await verifier.verifyOTP(phone, otpCode, 'sms');

    if (!otpResult.success) {
      throw new Error('OTP verification failed');
    }

    // Step 3: Create session
    const token = await createSession(user.id);

    return {
      success: true,
      token,
      user,
    };
  } catch (error) {
    console.error('Login failed:', error);
    throw error;
  }
}
```

### Python

```python
import requests
import base64
from typing import Optional, Literal, Dict, Any
from enum import Enum

class OTPErrorType(Enum):
    INVALID_OTP = "INVALID_OTP"
    EXPIRED_OTP = "EXPIRED_OTP"
    MAX_ATTEMPTS_EXCEEDED = "MAX_ATTEMPTS_EXCEEDED"
    OTP_ALREADY_USED = "OTP_ALREADY_USED"
    OTP_NOT_FOUND = "OTP_NOT_FOUND"

class OTPVerificationService:
    def __init__(self, api_key: str, api_secret: str):
        self.base_url = "https://api.sendexa.co/v1/otp"
        credentials = f"{api_key}:{api_secret}"
        self.auth_header = base64.b64encode(credentials.encode()).decode()
        self.headers = {
            "Authorization": f"Basic {self.auth_header}",
            "Content-Type": "application/json"
        }
        self.attempt_tracking = {}

    def verify_otp(
        self,
        destination: str,
        code: str,
        channel: Literal['sms', 'email'] = 'sms',
        otp_id: Optional[str] = None
    ) -> Dict[str, Any]:
        # Track local attempts
        attempts = self.attempt_tracking.get(destination, 0)

        if attempts >= 3:
            raise Exception("Maximum local attempts exceeded")

        payload = {"code": code}

        if channel == 'sms':
            payload['phone'] = destination
        elif channel == 'email':
            payload['email'] = destination

        if otp_id:
            payload['id'] = otp_id

        try:
            response = requests.post(
                f"{self.base_url}/verify",
                json=payload,
                headers=self.headers
            )

            if response.status_code == 400:
                # Increment attempts
                self.attempt_tracking[destination] = attempts + 1

                error_data = response.json()
                error_type = error_data.get('errorType')

                if error_type == OTPErrorType.INVALID_OTP.value:
                    remaining = error_data.get('data', {}).get('attemptsRemaining', 0)
                    raise ValueError(f"Invalid OTP. {remaining} attempts remaining.")

                elif error_type == OTPErrorType.EXPIRED_OTP.value:
                    raise ValueError("OTP has expired. Please request a new one.")

                elif error_type == OTPErrorType.MAX_ATTEMPTS_EXCEEDED.value:
                    self.attempt_tracking[destination] = 999  # Lock out
                    raise ValueError("Maximum attempts exceeded. Request a new OTP.")

                elif error_type == OTPErrorType.OTP_ALREADY_USED.value:
                    raise ValueError("This OTP has already been used.")

                elif error_type == OTPErrorType.OTP_NOT_FOUND.value:
                    raise ValueError("No OTP found. Please request one first.")

                else:
                    raise ValueError(error_data.get('message', 'Verification failed'))

            elif response.status_code == 404:
                raise ValueError("No OTP found for this destination")

            response.raise_for_status()

            # Clear attempts on success
            if destination in self.attempt_tracking:
                del self.attempt_tracking[destination]

            return response.json()

        except requests.exceptions.RequestException as e:
            raise Exception(f"Verification failed: {str(e)}")

    def get_remaining_attempts(self, destination: str) -> int:
        """Get remaining verification attempts"""
        attempts = self.attempt_tracking.get(destination, 0)
        return max(0, 3 - attempts)

    def reset_attempts(self, destination: str):
        """Reset attempt counter"""
        if destination in self.attempt_tracking:
            del self.attempt_tracking[destination]

# Usage Examples

verifier = OTPVerificationService("your_api_key", "your_api_secret")

# Verify SMS OTP
def handle_sms_verification(phone: str, code: str) -> bool:
    try:
        result = verifier.verify_otp(phone, code, channel='sms')

        if result['success']:
            print("‚úÖ Verification successful!")
            print(f"Metadata: {result['data']['metadata']}")

            # Process transaction
            metadata = result['data']['metadata']
            process_transaction(metadata['transactionId'], metadata['amount'])

            return True

    except ValueError as e:
        print(f"‚ùå Verification failed: {e}")
        remaining = verifier.get_remaining_attempts(phone)
        if remaining > 0:
            print(f"{remaining} attempts remaining")
        return False
    except Exception as e:
        print(f"‚ùå Error: {e}")
        return False

# Verify Email OTP
def handle_email_verification(email: str, code: str) -> bool:
    try:
        result = verifier.verify_otp(email, code, channel='email')

        if result['success']:
            print("‚úÖ Email verified!")
            mark_email_as_verified(email)
            return True

    except ValueError as e:
        print(f"‚ùå Verification failed: {e}")
        return False

# FastAPI integration
from fastapi import HTTPException

@app.post("/verify-transaction")
async def verify_transaction(
    phone: str,
    otp_code: str,
    transaction_id: str
):
    try:
        result = verifier.verify_otp(phone, otp_code, channel='sms')

        if not result['success']:
            raise HTTPException(status_code=400, detail="Verification failed")

        # Extract metadata
        metadata = result['data']['metadata']

        # Verify transaction matches
        if metadata.get('transactionId') != transaction_id:
            raise HTTPException(status_code=400, detail="Transaction mismatch")

        # Process transaction
        await process_transaction(transaction_id, metadata['amount'])

        return {
            "success": True,
            "message": "Transaction completed successfully",
            "transaction_id": transaction_id,
            "amount": metadata['amount']
        }

    except ValueError as e:
        remaining = verifier.get_remaining_attempts(phone)
        raise HTTPException(
            status_code=400,
            detail={
                "message": str(e),
                "attemptsRemaining": remaining
            }
        )
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
```

### PHP

```php
<?php

class OTPVerificationService {
    private $baseUrl;
    private $credentials;
    private $attemptTracking = [];

    public function __construct($apiKey, $apiSecret) {
        $this->baseUrl = 'https://api.sendexa.co/v1/otp';
        $this->credentials = base64_encode("$apiKey:$apiSecret");
    }

    public function verifyOTP($destination, $code, $channel = 'sms', $otpId = null) {
        // Track local attempts
        $attempts = $this->attemptTracking[$destination] ?? 0;

        if ($attempts >= 3) {
            throw new Exception('Maximum local attempts exceeded');
        }

        $payload = ['code' => $code];

        if ($channel === 'sms') {
            $payload['phone'] = $destination;
        } elseif ($channel === 'email') {
            $payload['email'] = $destination;
        }

        if ($otpId) {
            $payload['id'] = $otpId;
        }

        $ch = curl_init("{$this->baseUrl}/verify");
        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
        curl_setopt($ch, CURLOPT_POST, true);
        curl_setopt($ch, CURLOPT_POSTFIELDS, json_encode($payload));
        curl_setopt($ch, CURLOPT_HTTPHEADER, [
            "Authorization: Basic {$this->credentials}",
            'Content-Type: application/json'
        ]);

        $response = curl_exec($ch);
        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);
        curl_close($ch);

        $result = json_decode($response, true);

        if ($httpCode === 400) {
            // Increment attempts
            $this->attemptTracking[$destination] = $attempts + 1;

            $errorType = $result['errorType'] ?? '';

            if ($errorType === 'INVALID_OTP') {
                $remaining = $result['data']['attemptsRemaining'] ?? 0;
                throw new Exception("Invalid OTP. $remaining attempts remaining.");
            } elseif ($errorType === 'EXPIRED_OTP') {
                throw new Exception('OTP has expired. Please request a new one.');
            } elseif ($errorType === 'MAX_ATTEMPTS_EXCEEDED') {
                $this->attemptTracking[$destination] = 999;
                throw new Exception('Maximum attempts exceeded.');
            } elseif ($errorType === 'OTP_ALREADY_USED') {
                throw new Exception('This OTP has already been used.');
            } elseif ($errorType === 'OTP_NOT_FOUND') {
                throw new Exception('No OTP found.');
            } else {
                throw new Exception($result['message'] ?? 'Verification failed');
            }
        } elseif ($httpCode === 404) {
            throw new Exception('No OTP found for this destination');
        } elseif ($httpCode !== 200) {
            throw new Exception("Verification failed: $response");
        }

        // Clear attempts on success
        unset($this->attemptTracking[$destination]);

        return $result;
    }

    public function getRemainingAttempts($destination) {
        $attempts = $this->attemptTracking[$destination] ?? 0;
        return max(0, 3 - $attempts);
    }

    public function resetAttempts($destination) {
        unset($this->attemptTracking[$destination]);
    }
}

// Usage Examples

$verifier = new OTPVerificationService('your_api_key', 'your_api_secret');

// Verify SMS OTP
function handleSMSVerification($phone, $code) {
    global $verifier;

    try {
        $result = $verifier->verifyOTP($phone, $code, 'sms');

        if ($result['success']) {
            echo "‚úÖ Verification successful!\n";
            echo "Metadata: " . json_encode($result['data']['metadata']) . "\n";

            // Process transaction
            $metadata = $result['data']['metadata'];
            processTransaction($metadata['transactionId'], $metadata['amount']);

            return true;
        }
    } catch (Exception $e) {
        echo "‚ùå Verification failed: " . $e->getMessage() . "\n";

        $remaining = $verifier->getRemainingAttempts($phone);
        if ($remaining > 0) {
            echo "$remaining attempts remaining\n";
        }

        return false;
    }
}

// Verify Email OTP
function handleEmailVerification($email, $code) {
    global $verifier;

    try {
        $result = $verifier->verifyOTP($email, $code, 'email');

        if ($result['success']) {
            echo "‚úÖ Email verified!\n";
            markEmailAsVerified($email);
            return true;
        }
    } catch (Exception $e) {
        echo "‚ùå Verification failed: " . $e->getMessage() . "\n";
        return false;
    }
}

?>
```

---

## Frontend Integration

### React OTP Input Component

```javascript
import { useState } from 'react';

function OTPVerificationForm({ phone, onSuccess }) {
  const [otp, setOTP] = useState('');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');
  const [attemptsRemaining, setAttemptsRemaining] = useState(3);

  const handleVerify = async (e) => {
    e.preventDefault();

    if (otp.length < 4) {
      setError('Please enter complete OTP');
      return;
    }

    setLoading(true);
    setError('');

    try {
      const response = await fetch('/api/verify-otp', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ phone, code: otp }),
      });

      const data = await response.json();

      if (data.success) {
        onSuccess(data.data);
      } else {
        setError(data.message);
        setAttemptsRemaining(data.data?.attemptsRemaining || 0);

        if (data.errorType === 'MAX_ATTEMPTS_EXCEEDED') {
          setError('Maximum attempts exceeded. Please request a new OTP.');
        }
      }
    } catch (err) {
      setError('Verification failed. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  return (
    <form onSubmit={handleVerify}>
      <input
        type="text"
        value={otp}
        onChange={(e) => setOTP(e.target.value.replace(/\D/g, ''))}
        maxLength={6}
        placeholder="Enter OTP"
        disabled={loading || attemptsRemaining === 0}
      />

      {error && <p className="error">{error}</p>}

      {attemptsRemaining > 0 && attemptsRemaining < 3 && (
        <p className="warning">
          {attemptsRemaining} attempt{attemptsRemaining > 1 ? 's' : ''}{' '}
          remaining
        </p>
      )}

      <button
        type="submit"
        disabled={loading || otp.length < 4 || attemptsRemaining === 0}
      >
        {loading ? 'Verifying...' : 'Verify OTP'}
      </button>
    </form>
  );
}
```

---

## Best Practices

### 1. Always Verify Server-Side

**‚ùå Never:**

```javascript
// INSECURE - Client-side only
if (userOTP === savedOTP) {
  grantAccess();
}
```

**‚úÖ Always:**

```javascript
// SECURE - Server verification
const verified = await verifyOTPOnServer(phone, userOTP);
if (verified) {
  grantAccess();
}
```

### 2. Handle All Error Types

```javascript
async function verifyWithProperErrorHandling(phone, code) {
  try {
    const result = await verifyOTP(phone, code);
    return { success: true, data: result.data };
  } catch (error) {
    if (error.message.includes('Invalid OTP')) {
      return { success: false, error: 'wrong_code', canRetry: true };
    } else if (error.message.includes('expired')) {
      return { success: false, error: 'expired', canRetry: false };
    } else if (error.message.includes('Maximum attempts')) {
      return { success: false, error: 'max_attempts', canRetry: false };
    } else {
      return { success: false, error: 'unknown', canRetry: true };
    }
  }
}
```

### 3. Use Metadata for Context Validation

```javascript
async function verifyTransactionOTP(phone, code, transactionId, amount) {
  const result = await verifyOTP(phone, code);

  if (!result.success) {
    throw new Error('OTP verification failed');
  }

  // Validate metadata matches transaction
  const metadata = result.data.metadata;

  if (metadata.transactionId !== transactionId) {
    throw new Error('Transaction mismatch');
  }

  if (metadata.amount !== amount) {
    throw new Error('Amount mismatch');
  }

  return true;
}
```

### 4. Clear Input on Error

```javascript
function handleVerificationError(error, otpInputRef) {
  // Clear OTP input
  otpInputRef.current.value = '';

  // Show error
  showError(error.message);

  // Focus input
  otpInputRef.current.focus();

  // Log for security monitoring
  logSecurityEvent('otp_verification_failed', { error: error.message });
}
```

---

## Testing

### Test OTP Codes (Sandbox)

| Code     | Behavior                    |
| -------- | --------------------------- |
| `123456` | Always valid                |
| `000000` | Always invalid              |
| `999999` | Triggers max attempts error |
| `111111` | Simulates expired OTP       |

---

## Next Steps

- üîÑ **[Resend OTP](/docs/verify/resend)** - Handle resend requests
- üìù **[Request OTP](/docs/verify/request)** - Send initial OTP
- üîî **[Webhooks](/docs/verify/webhooks)** - Real-time notifications
- üìñ **[API Reference](/docs/verify/v1)** - Complete documentation
