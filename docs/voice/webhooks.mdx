---
title: Voice Call Events & Webhooks
description: Receive real-time voice call events via webhooks. Track call status, handle user input, and build responsive voice applications.
date: 2025-03-12
---

# Voice Call Events & Webhooks

Receive real-time notifications about voice call events. Sendexa sends HTTP POST requests to your server whenever important call events occur.

---

## Overview

### What Are Webhooks?

Webhooks are HTTP callbacks that Sendexa sends to your server when call events occur. Instead of polling for call status, your application receives instant notifications.

### Benefits

- **Real-time** - Instant event notifications
- **Efficient** - No polling required
- **Reliable** - Automatic retry mechanism
- **Scalable** - Handle thousands of events
- **Complete Data** - Full call information in each event

---

## Webhook Events

### Call Lifecycle Events

| Event            | Description         | When Triggered               |
| ---------------- | ------------------- | ---------------------------- |
| `call.initiated` | Call started        | Immediately after API call   |
| `call.ringing`   | Phone is ringing    | When recipient's phone rings |
| `call.answered`  | Call was answered   | When call is picked up       |
| `call.completed` | Call ended normally | When call ends successfully  |
| `call.failed`    | Call failed         | When call fails to connect   |
| `call.busy`      | Number was busy     | When recipient is busy       |
| `call.no-answer` | No one answered     | When call times out          |
| `call.canceled`  | Call was canceled   | When call is canceled        |

### IVR Events

| Event                 | Description           | When Triggered           |
| --------------------- | --------------------- | ------------------------ |
| `gather.complete`     | Input collected       | After user presses keys  |
| `recording.completed` | Recording ready       | After recording finishes |
| `dial.completed`      | Call forwarding ended | After dial completes     |

---

## Webhook Payload

### Call Status Webhook

```json
{
  "event": "call.answered",
  "call_id": "call_abc123def456",
  "account_id": "acc_xyz789",
  "from": "233302123456",
  "to": "233501234567",
  "direction": "outbound",
  "status": "in-progress",
  "answered_at": "2025-03-12T14:20:15Z",
  "duration": 0,
  "timestamp": "2025-03-12T14:20:15Z"
}
```

### Common Fields

| Field        | Type   | Description                |
| ------------ | ------ | -------------------------- |
| `event`      | string | Event type                 |
| `call_id`    | string | Unique call identifier     |
| `account_id` | string | Your account ID            |
| `from`       | string | Caller phone number        |
| `to`         | string | Recipient phone number     |
| `direction`  | string | `outbound` or `inbound`    |
| `status`     | string | Current call status        |
| `timestamp`  | string | Event timestamp (ISO 8601) |

### Call Completed Event

```json
{
  "event": "call.completed",
  "call_id": "call_abc123def456",
  "from": "233302123456",
  "to": "233501234567",
  "direction": "outbound",
  "status": "completed",
  "duration": 185,
  "cost": 0.46,
  "currency": "GHS",
  "answered_at": "2025-03-12T14:20:15Z",
  "completed_at": "2025-03-12T14:23:20Z",
  "timestamp": "2025-03-12T14:23:20Z"
}
```

### Call Failed Event

```json
{
  "event": "call.failed",
  "call_id": "call_abc123def456",
  "from": "233302123456",
  "to": "233501234567",
  "direction": "outbound",
  "status": "failed",
  "error": {
    "code": "BUSY",
    "message": "The number is busy"
  },
  "timestamp": "2025-03-12T14:20:05Z"
}
```

### Recording Completed Event

```json
{
  "event": "recording.completed",
  "call_id": "call_abc123def456",
  "recording_id": "rec_xyz789abc012",
  "recording_url": "https://recordings.sendexa.co/rec_xyz789abc012.mp3",
  "duration": 45,
  "size": 720000,
  "format": "mp3",
  "timestamp": "2025-03-12T14:25:00Z"
}
```

---

## Configuration

### Setting Up Webhooks

1. **Log in** to [dashboard.sendexa.co](https://dashboard.sendexa.co)
2. Navigate to **Voice ‚Üí Webhooks**
3. Click **Add Webhook**
4. Configure:
   - **URL:** Your HTTPS endpoint
   - **Events:** Select events to receive
   - **Secret:** Generate webhook secret
5. Click **Save & Test**

### Webhook URL Requirements

‚úÖ **Required:**

- Must use HTTPS (not HTTP)
- Must be publicly accessible
- Should respond within 10 seconds
- Should return 200 OK on success

‚ùå **Not Allowed:**

- HTTP URLs (security requirement)
- Localhost/private IPs
- URLs requiring authentication

---

## Implementing Webhook Handlers

### Node.js / Express

```javascript
const express = require('express');
const crypto = require('crypto');

const app = express();
app.use(express.json());

const WEBHOOK_SECRET = 'your_webhook_secret_from_dashboard';

// Verify webhook signature
function verifySignature(payload, signature) {
  const expectedSignature = crypto
    .createHmac('sha256', WEBHOOK_SECRET)
    .update(JSON.stringify(payload))
    .digest('hex');

  return crypto.timingSafeEqual(
    Buffer.from(signature),
    Buffer.from(expectedSignature)
  );
}

// Webhook endpoint
app.post('/webhooks/voice', async (req, res) => {
  const signature = req.headers['x-sendexa-signature'];

  // Verify signature
  if (!verifySignature(req.body, signature)) {
    console.error('Invalid signature');
    return res.status(401).send('Unauthorized');
  }

  const event = req.body;
  console.log('Received event:', event.event);

  // Handle different event types
  switch (event.event) {
    case 'call.initiated':
      await handleCallInitiated(event);
      break;

    case 'call.answered':
      await handleCallAnswered(event);
      break;

    case 'call.completed':
      await handleCallCompleted(event);
      break;

    case 'call.failed':
      await handleCallFailed(event);
      break;

    case 'recording.completed':
      await handleRecordingCompleted(event);
      break;

    default:
      console.log('Unknown event:', event.event);
  }

  // Respond quickly (within 10 seconds)
  res.status(200).send('OK');
});

async function handleCallInitiated(event) {
  console.log(`Call initiated: ${event.call_id}`);

  // Update database
  await db.calls.create({
    id: event.call_id,
    from: event.from,
    to: event.to,
    status: 'initiated',
    createdAt: event.timestamp,
  });
}

async function handleCallAnswered(event) {
  console.log(`Call answered: ${event.call_id}`);

  // Update database
  await db.calls.update({
    where: { id: event.call_id },
    data: {
      status: 'answered',
      answeredAt: event.answered_at,
    },
  });

  // Send notification
  await notifyUser(event.call_id, 'Your call was answered');
}

async function handleCallCompleted(event) {
  console.log(`Call completed: ${event.call_id}`);
  console.log(
    `Duration: ${event.duration}s, Cost: ${event.cost} ${event.currency}`
  );

  // Update database
  await db.calls.update({
    where: { id: event.call_id },
    data: {
      status: 'completed',
      duration: event.duration,
      cost: event.cost,
      completedAt: event.completed_at,
    },
  });

  // Generate invoice
  await generateInvoice(event.call_id);
}

async function handleCallFailed(event) {
  console.error(`Call failed: ${event.call_id}`, event.error);

  // Update database
  await db.calls.update({
    where: { id: event.call_id },
    data: {
      status: 'failed',
      errorCode: event.error.code,
      errorMessage: event.error.message,
    },
  });

  // Notify admin
  await alertAdmin(`Call ${event.call_id} failed: ${event.error.message}`);
}

async function handleRecordingCompleted(event) {
  console.log(`Recording ready: ${event.recording_id}`);

  // Save recording info
  await db.recordings.create({
    id: event.recording_id,
    callId: event.call_id,
    url: event.recording_url,
    duration: event.duration,
    createdAt: event.timestamp,
  });

  // Notify user
  await notifyRecordingReady(event.call_id, event.recording_url);
}

app.listen(3000, () => {
  console.log('Webhook server listening on port 3000');
});
```

### Python / Flask

```python
from flask import Flask, request, jsonify
import hmac
import hashlib
import json

app = Flask(__name__)

WEBHOOK_SECRET = 'your_webhook_secret_from_dashboard'

def verify_signature(payload, signature):
    """Verify webhook signature"""
    expected_signature = hmac.new(
        WEBHOOK_SECRET.encode(),
        json.dumps(payload).encode(),
        hashlib.sha256
    ).hexdigest()

    return hmac.compare_digest(signature, expected_signature)

@app.route('/webhooks/voice', methods=['POST'])
def handle_webhook():
    signature = request.headers.get('X-Sendexa-Signature')
    payload = request.get_json()

    # Verify signature
    if not verify_signature(payload, signature):
        return jsonify({'error': 'Invalid signature'}), 401

    event_type = payload.get('event')
    print(f"Received event: {event_type}")

    # Handle different event types
    if event_type == 'call.initiated':
        handle_call_initiated(payload)
    elif event_type == 'call.answered':
        handle_call_answered(payload)
    elif event_type == 'call.completed':
        handle_call_completed(payload)
    elif event_type == 'call.failed':
        handle_call_failed(payload)
    elif event_type == 'recording.completed':
        handle_recording_completed(payload)
    else:
        print(f"Unknown event: {event_type}")

    return jsonify({'status': 'success'}), 200

def handle_call_initiated(event):
    """Handle call initiated event"""
    print(f"Call initiated: {event['call_id']}")
    # Update database
    # db.calls.insert(event)

def handle_call_answered(event):
    """Handle call answered event"""
    print(f"Call answered: {event['call_id']}")
    # Update database
    # Send notification

def handle_call_completed(event):
    """Handle call completed event"""
    print(f"Call completed: {event['call_id']}")
    print(f"Duration: {event['duration']}s, Cost: {event['cost']}")
    # Update database
    # Generate invoice

def handle_call_failed(event):
    """Handle call failed event"""
    print(f"Call failed: {event['call_id']}", event['error'])
    # Update database
    # Alert admin

def handle_recording_completed(event):
    """Handle recording completed event"""
    print(f"Recording ready: {event['recording_id']}")
    # Save recording info
    # Notify user

if __name__ == '__main__':
    app.run(port=3000)
```

### PHP

```php
<?php

$webhookSecret = 'your_webhook_secret_from_dashboard';

// Get payload and signature
$payload = file_get_contents('php://input');
$signature = $_SERVER['HTTP_X_SENDEXA_SIGNATURE'] ?? '';

// Verify signature
$expectedSignature = hash_hmac('sha256', $payload, $webhookSecret);

if (!hash_equals($signature, $expectedSignature)) {
    http_response_code(401);
    die('Unauthorized');
}

// Parse event
$event = json_decode($payload, true);

// Handle event
switch ($event['event']) {
    case 'call.initiated':
        handleCallInitiated($event);
        break;

    case 'call.answered':
        handleCallAnswered($event);
        break;

    case 'call.completed':
        handleCallCompleted($event);
        break;

    case 'call.failed':
        handleCallFailed($event);
        break;

    case 'recording.completed':
        handleRecordingCompleted($event);
        break;

    default:
        error_log("Unknown event: " . $event['event']);
}

// Respond
http_response_code(200);
echo 'OK';

function handleCallInitiated($event) {
    error_log("Call initiated: " . $event['call_id']);
    // Update database
}

function handleCallAnswered($event) {
    error_log("Call answered: " . $event['call_id']);
    // Update database
    // Send notification
}

function handleCallCompleted($event) {
    error_log("Call completed: " . $event['call_id']);
    // Update database
    // Generate invoice
}

function handleCallFailed($event) {
    error_log("Call failed: " . $event['call_id']);
    // Update database
    // Alert admin
}

function handleRecordingCompleted($event) {
    error_log("Recording ready: " . $event['recording_id']);
    // Save recording info
    // Notify user
}

?>
```

---

## Security

### Signature Verification

Every webhook includes a signature in the `X-Sendexa-Signature` header. **Always verify** this signature.

**How Signature is Generated:**

```
HMAC-SHA256(webhook_secret, request_body)
```

### Best Practices

1. **Always use HTTPS** - Encrypt webhook traffic
2. **Verify signatures** - Prevent unauthorized requests
3. **Use timing-safe comparison** - Prevent timing attacks
4. **Validate payload structure** - Check required fields
5. **Process asynchronously** - Return 200 quickly
6. **Log all webhooks** - For debugging and auditing
7. **Implement idempotency** - Handle duplicate deliveries

---

## Retry Policy

If your endpoint doesn't respond with `200 OK`, Sendexa will retry:

| Attempt | Delay      | Total Elapsed |
| ------- | ---------- | ------------- |
| 1       | Immediate  | 0s            |
| 2       | 30 seconds | 30s           |
| 3       | 2 minutes  | 2.5 min       |
| 4       | 10 minutes | 12.5 min      |
| 5       | 1 hour     | 1h 12.5min    |

After 5 failed attempts, the webhook is marked as failed.

### Retry Headers

Retry attempts include additional headers:

```http
X-Sendexa-Delivery-Attempt: 2
X-Sendexa-Delivery-ID: del_a8f92bc3f2c44755
```

### Handling Retries (Idempotency)

```javascript
const processedEvents = new Set();

app.post('/webhooks/voice', (req, res) => {
  const deliveryId = req.headers['x-sendexa-delivery-id'];

  // Check if already processed
  if (processedEvents.has(deliveryId)) {
    console.log('Event already processed:', deliveryId);
    return res.status(200).send('OK');
  }

  // Process event
  handleEvent(req.body);

  // Mark as processed
  processedEvents.add(deliveryId);

  res.status(200).send('OK');
});
```

**Better approach (using database):**

```javascript
app.post('/webhooks/voice', async (req, res) => {
  const deliveryId = req.headers['x-sendexa-delivery-id'];

  // Check database
  const exists = await db.webhookEvents.findOne({ deliveryId });

  if (exists) {
    return res.status(200).send('OK');
  }

  // Store and process
  await db.webhookEvents.create({
    deliveryId,
    event: req.body,
    processedAt: new Date(),
  });

  await handleEvent(req.body);

  res.status(200).send('OK');
});
```

---

## Testing Webhooks

### Local Development with ngrok

```bash
# Install ngrok
npm install -g ngrok

# Start your local server
node server.js

# Create public tunnel
ngrok http 3000

# Use the HTTPS URL in dashboard
# https://abc123.ngrok.io/webhooks/voice
```

### Manual Testing

Test webhooks from your dashboard:

1. Go to **Voice ‚Üí Webhooks**
2. Select your webhook
3. Click **Send Test Event**
4. Choose event type
5. View response and logs

### Example Test Payload

```json
{
  "event": "call.completed",
  "call_id": "test_call_123456",
  "from": "233302123456",
  "to": "233501234567",
  "direction": "outbound",
  "status": "completed",
  "duration": 120,
  "cost": 0.3,
  "currency": "GHS",
  "answered_at": "2025-03-12T14:20:15Z",
  "completed_at": "2025-03-12T14:22:15Z",
  "timestamp": "2025-03-12T14:22:15Z"
}
```

---

## Common Use Cases

### 1. Call Analytics Dashboard

```javascript
async function handleCallCompleted(event) {
  // Store call data
  await db.calls.create({
    id: event.call_id,
    from: event.from,
    to: event.to,
    duration: event.duration,
    cost: event.cost,
    completedAt: event.completed_at,
  });

  // Update analytics
  await updateAnalytics({
    totalCalls: 1,
    totalDuration: event.duration,
    totalCost: event.cost,
    date: new Date(event.completed_at).toDateString(),
  });
}
```

### 2. Customer Notification System

```javascript
async function handleCallAnswered(event) {
  // Notify customer their call was answered
  await sendSMS({
    to: event.from,
    message: `Your call to ${event.to} was answered and is in progress.`,
  });
}

async function handleCallCompleted(event) {
  // Send call summary
  await sendEmail({
    to: getCustomerEmail(event.from),
    subject: 'Call Summary',
    body: `
      Call Duration: ${event.duration} seconds
      Cost: ${event.cost} ${event.currency}
      Time: ${event.completed_at}
    `,
  });
}
```

### 3. Auto-Retry Failed Calls

```javascript
async function handleCallFailed(event) {
  const call = await db.calls.findOne({ id: event.call_id });

  // Retry if busy or no answer
  if (['BUSY', 'NO_ANSWER'].includes(event.error.code)) {
    const retryCount = call.retryCount || 0;

    if (retryCount < 3) {
      // Wait and retry
      setTimeout(
        async () => {
          await makeCall({
            to: event.to,
            from: event.from,
            url: call.voiceUrl,
          });

          // Update retry count
          await db.calls.update({
            where: { id: event.call_id },
            data: { retryCount: retryCount + 1 },
          });
        },
        (retryCount + 1) * 60000
      ); // Wait 1, 2, 3 minutes
    }
  }
}
```

### 4. Recording Transcription

```javascript
async function handleRecordingCompleted(event) {
  // Download recording
  const audioBuffer = await downloadFile(event.recording_url);

  // Send to transcription service
  const transcription = await transcribeAudio(audioBuffer);

  // Save transcription
  await db.recordings.update({
    where: { id: event.recording_id },
    data: {
      transcription: transcription.text,
      transcribedAt: new Date(),
    },
  });

  // Notify user
  await notifyUser(event.call_id, 'Recording transcription is ready');
}
```

---

## Monitoring & Debugging

### Webhook Logs

View webhook delivery logs in your dashboard:

1. Navigate to **Voice ‚Üí Webhooks**
2. Click on webhook URL
3. View **Delivery Logs** tab

**Log Information:**

- Timestamp
- Event type
- HTTP status code
- Response time
- Request/response body
- Retry attempts

### Failed Webhooks

Monitor and retry failed webhooks:

1. Go to **Webhooks ‚Üí Failed Deliveries**
2. View error details
3. Click **Retry** to resend manually

---

## Best Practices Checklist

- [ ] Use HTTPS for webhook URLs
- [ ] Verify webhook signatures
- [ ] Respond within 10 seconds
- [ ] Return 200 OK on success
- [ ] Process events asynchronously
- [ ] Implement idempotency
- [ ] Log all webhook events
- [ ] Monitor webhook health
- [ ] Handle retries gracefully
- [ ] Test with different event types
- [ ] Set up alerts for failures
- [ ] Document webhook handler

---

## Next Steps

- üìû **[Make Calls](/docs/voice/make-call)** - Start making calls
- üì¢ **[Broadcast](/docs/voice/broadcast)** - Send to multiple
- üéõÔ∏è **[Build IVR](/docs/voice/ivr)** - Interactive menus
- üõ†Ô∏è **[API Reference](/docs/voice/v1)** - Complete docs
